---
layout: post
title: Blog Post 1
---

In this blog post, I will create several interesting, interactive data graphics using the NOAA climate data.

## 1. Create a Database

First, create a database with three tables: temperatures, stations, and countries. Before we get started, let's do some standard import.


```python
import sqlite3
import numpy as np
import pandas as pd
```

After importing the sqlite3 module, the first thing we should do is connect to a database. In case the specified database does not exist, instantiating the connection will also create an empty database with the specified name.


```python
conn = sqlite3.connect("database.db") # create a database in current directory called database.db
```

There are many ways to add data to a database. Since we are already familiar with Pandas data frames, we'll make use of some extremely convenient functionality which allows us to directly write data frames to a database. The whole point of this was to avoid reading in an entire data frame. Pandas supplies a nice approach to this using the familiar pd.read_csv() function. Supplying a value of chunksize will cause read_csv() to return not a data frame but an iterator, each of whose elements is a piece of the data with number of rows equal to chunksize.  
Let's first load the temperature dataset.


```python
temperatures_iter = pd.read_csv("temps.csv", chunksize = 100000)
```

The data is read "on the fly" -- i.e. it's not actually read until we start querying the iterator. 


```python
temperatures = temperatures_iter.__next__()
```

Let's take a look at this dataset.


```python
temperatures.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Year</th>
      <th>VALUE1</th>
      <th>VALUE2</th>
      <th>VALUE3</th>
      <th>VALUE4</th>
      <th>VALUE5</th>
      <th>VALUE6</th>
      <th>VALUE7</th>
      <th>VALUE8</th>
      <th>VALUE9</th>
      <th>VALUE10</th>
      <th>VALUE11</th>
      <th>VALUE12</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>-89.0</td>
      <td>236.0</td>
      <td>472.0</td>
      <td>773.0</td>
      <td>1128.0</td>
      <td>1599.0</td>
      <td>1570.0</td>
      <td>1481.0</td>
      <td>1413.0</td>
      <td>1174.0</td>
      <td>510.0</td>
      <td>-39.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ACW00011604</td>
      <td>1962</td>
      <td>113.0</td>
      <td>85.0</td>
      <td>-154.0</td>
      <td>635.0</td>
      <td>908.0</td>
      <td>1381.0</td>
      <td>1510.0</td>
      <td>1393.0</td>
      <td>1163.0</td>
      <td>994.0</td>
      <td>323.0</td>
      <td>-126.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ACW00011604</td>
      <td>1963</td>
      <td>-713.0</td>
      <td>-553.0</td>
      <td>-99.0</td>
      <td>541.0</td>
      <td>1224.0</td>
      <td>1627.0</td>
      <td>1620.0</td>
      <td>1596.0</td>
      <td>1332.0</td>
      <td>940.0</td>
      <td>566.0</td>
      <td>-108.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ACW00011604</td>
      <td>1964</td>
      <td>62.0</td>
      <td>-85.0</td>
      <td>55.0</td>
      <td>738.0</td>
      <td>1219.0</td>
      <td>1442.0</td>
      <td>1506.0</td>
      <td>1557.0</td>
      <td>1221.0</td>
      <td>788.0</td>
      <td>546.0</td>
      <td>112.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ACW00011604</td>
      <td>1965</td>
      <td>44.0</td>
      <td>-105.0</td>
      <td>38.0</td>
      <td>590.0</td>
      <td>987.0</td>
      <td>1500.0</td>
      <td>1487.0</td>
      <td>1477.0</td>
      <td>1377.0</td>
      <td>974.0</td>
      <td>31.0</td>
      <td>-178.0</td>
    </tr>
  </tbody>
</table>
</div>



Great! Actually, there are a few cleaning steps that we'll make before incorporating this data into our database. 


```python
def prepare_df(df):
    df = df.set_index(keys=["ID", "Year"])
    df = df.stack()
    df = df.reset_index()
    df = df.rename(columns = {"level_2"  : "Month" , 0 : "Temp"})
    df["Month"] = df["Month"].str[5:].astype(int)
    df["Temp"]  = df["Temp"] / 100
    return(df)
```


```python
temperatures = prepare_df(temperatures)
temperatures.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>1</td>
      <td>-0.89</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>2</td>
      <td>2.36</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>3</td>
      <td>4.72</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>4</td>
      <td>7.73</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>5</td>
      <td>11.28</td>
    </tr>
  </tbody>
</table>
</div>



Ok! We are finally ready to populate a table in our database.

You can think of a table as a data frame-like object, represented in SQLite rather than in Python. The df.to_sql() method writes to a specified table in the database (the conn object from earlier). We need to specify if_exists to ensure that we add each piece to the table, rather than overwriting them each time.


```python
for df in temperatures_iter:
    df = prepare_df(df)
    df.to_sql("temperatures", conn, if_exists = "append", index = False)
```

Similarly, let's add stations and countries to our database. These are pretty small data sets so we don't need to worry about reading it in by chunks.


```python
stations = pd.read_csv("station-metadata.csv")
stations.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>STNELEV</th>
      <th>NAME</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>57.7667</td>
      <td>11.8667</td>
      <td>18.0</td>
      <td>SAVE</td>
    </tr>
    <tr>
      <th>1</th>
      <td>AE000041196</td>
      <td>25.3330</td>
      <td>55.5170</td>
      <td>34.0</td>
      <td>SHARJAH_INTER_AIRP</td>
    </tr>
    <tr>
      <th>2</th>
      <td>AEM00041184</td>
      <td>25.6170</td>
      <td>55.9330</td>
      <td>31.0</td>
      <td>RAS_AL_KHAIMAH_INTE</td>
    </tr>
    <tr>
      <th>3</th>
      <td>AEM00041194</td>
      <td>25.2550</td>
      <td>55.3640</td>
      <td>10.4</td>
      <td>DUBAI_INTL</td>
    </tr>
    <tr>
      <th>4</th>
      <td>AEM00041216</td>
      <td>24.4300</td>
      <td>54.4700</td>
      <td>3.0</td>
      <td>ABU_DHABI_BATEEN_AIR</td>
    </tr>
  </tbody>
</table>
</div>




```python
stations.to_sql("stations", conn, if_exists = "replace", index = False)
```


```python
countries = pd.read_csv("countries.csv")
countries.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>FIPS 10-4</th>
      <th>ISO 3166</th>
      <th>Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>AF</td>
      <td>AF</td>
      <td>Afghanistan</td>
    </tr>
    <tr>
      <th>1</th>
      <td>AX</td>
      <td>-</td>
      <td>Akrotiri</td>
    </tr>
    <tr>
      <th>2</th>
      <td>AL</td>
      <td>AL</td>
      <td>Albania</td>
    </tr>
    <tr>
      <th>3</th>
      <td>AG</td>
      <td>DZ</td>
      <td>Algeria</td>
    </tr>
    <tr>
      <th>4</th>
      <td>AQ</td>
      <td>AS</td>
      <td>American Samoa</td>
    </tr>
  </tbody>
</table>
</div>



Noticed that we have spaces in column names. We have to rename them otherwise we will get a user warning when adding `countries` to our database.


```python
countries = countries.rename(columns = {"FIPS 10-4":"FIPS_10-4","ISO 3166":"ISO_3166","Name":"Country"})
```


```python
countries.to_sql("countries", conn, if_exists = "replace", index = False)
```

Now we have a database containing three separate tables. Let's just check that this is indeed the case.


```python
cursor = conn.cursor()
cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
print(cursor.fetchall())
```

    [('temperatures',), ('stations',), ('countries',)]
    

Let's get more detailed information about the items in each table. For example, we can inspect the column names and data types in each. This is a good way to check that we actually populated our database correctly.


```python
cursor.execute("SELECT sql FROM sqlite_master WHERE type='table';")

for result in cursor.fetchall():
    print(result[0])
```

    CREATE TABLE "temperatures" (
    "ID" TEXT,
      "Year" INTEGER,
      "Month" INTEGER,
      "Temp" REAL
    )
    CREATE TABLE "stations" (
    "ID" TEXT,
      "LATITUDE" REAL,
      "LONGITUDE" REAL,
      "STNELEV" REAL,
      "NAME" TEXT
    )
    CREATE TABLE "countries" (
    "FIPS_10-4" TEXT,
      "ISO_3166" TEXT,
      "Country" TEXT
    )
    

This looks pretty good! We have three separate tables, called `temperatures`, `stations`, and `countries`. The column names are what we would expect. Notice that sql has automatically inferred the data types, such as REAL and TEXT, from the input.

It's good practice to close your database connection once you're done using it. Make sure to close the database connection after you are finished constructing it.


```python
conn.close()
```

Next time you need to pull some data from your database, just reopen the connection!

## 2. Write a Query Function

Like I mentioned in the previous section, we need to reopen the connection using this command.

`conn = sqlite3.connect("database.db")`

We are going to write a function called `query_climate_database()` which accepts four arguments:

`country`, a string giving the name of a country for which data should be returned.  
`year_begin` and `year_end`, two integers giving the earliest and latest years for which should be returned.  
`month`, an integer giving the month of the year for which should be returned.  
The return value of `query_climate_database()` is a Pandas dataframe of temperature readings for the specified country, in the specified date range, in the specified month of the year. This dataframe should have columns for:  

-The station name.  
-The latitude of the station.  
-The longitude of the station.  
-The name of the country in which the station is located.  
-The year in which the reading was taken.  
-The month in which the reading was taken.  
-The average temperature at the specified station during the specified year and month. (Note: the temperatures in the raw data are already averages by month, so you don’t have to do any aggregation at this stage.)  


```python
def query_climate_database(country, year_begin, year_end, month):
    """
    purpose: Creat a pandas dataframe using SQL commands 
    input: country, a string giving the name of a country for which data should be returned.
           year_begin and year_end, two integers giving the earliest and latest years for which should be returned.
           month, an integer giving the month of the year for which should be returned.
    output: A Pandas dataframe of temperature readings for the specified country, in the specified date range, in the specified month of the year. 
    """
    # open the connection
    conn = sqlite3.connect("database.db")
    
    cmd = \
    """
    SELECT S.NAME, S.LATITUDE, S.LONGITUDE, C.Country, T.Year, T.Month, T.Temp
    FROM stations S
    LEFT JOIN temperatures T ON S.ID = T.ID
    LEFT JOIN countries C ON SUBSTRING (T.ID, 1, 2) = C.`FIPS_10-4`
    WHERE T.Year >= {year_begin} AND T.Year <= {year_end} AND T.Month = {month} AND C.Country = '{country}'
    """.format(year_begin=year_begin, year_end=year_end, month=month, country=country)
    
    df = pd.read_sql_query(cmd, conn)
    # close the connection
    conn.close()
    return df
```

We can test our functions with the following code:


```python
query_climate_database(country = "India", 
                       year_begin = 1980, 
                       year_end = 2020,
                       month = 1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>1980</td>
      <td>1</td>
      <td>23.48</td>
    </tr>
    <tr>
      <th>1</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>1981</td>
      <td>1</td>
      <td>24.57</td>
    </tr>
    <tr>
      <th>2</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>1982</td>
      <td>1</td>
      <td>24.19</td>
    </tr>
    <tr>
      <th>3</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>1983</td>
      <td>1</td>
      <td>23.51</td>
    </tr>
    <tr>
      <th>4</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>1984</td>
      <td>1</td>
      <td>24.81</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>3147</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>India</td>
      <td>1983</td>
      <td>1</td>
      <td>5.10</td>
    </tr>
    <tr>
      <th>3148</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>India</td>
      <td>1986</td>
      <td>1</td>
      <td>6.90</td>
    </tr>
    <tr>
      <th>3149</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>India</td>
      <td>1994</td>
      <td>1</td>
      <td>8.10</td>
    </tr>
    <tr>
      <th>3150</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>India</td>
      <td>1995</td>
      <td>1</td>
      <td>5.60</td>
    </tr>
    <tr>
      <th>3151</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>India</td>
      <td>1997</td>
      <td>1</td>
      <td>5.70</td>
    </tr>
  </tbody>
</table>
<p>3152 rows × 7 columns</p>
</div>



## 3. Write a Geographic Scatter Function for Yearly Temperature Increases

To create Geographic Scatterplots, we will need to import `px`.


```python
from plotly import express as px
```

Next, we are going to write a function to create visualizations to address this question:

**How does the average yearly change in temperature vary within a given country?**

We are going to write a function called `temperature_coefficient_plot()`. This function should accept five explicit arguments, and an undetermined number of keyword arguments.

`country`, `year_begin`, `year_end`, and `month` should be as in the previous part.  
`min_obs`, the minimum required number of years of data for any given station. Only data for stations with at least min_obs years worth of data in the specified month should be plotted; the others should be filtered out. `df.transform()` plus filtering is a good way to achieve this task.  
`**kwargs`, additional keyword arguments passed to `px.scatter_mapbox()`. These can be used to control the colormap used, the mapbox style, etc.  
The output of this function should be an interactive geographic scatterplot, constructed using Plotly Express, with a point for each station, such that the color of the point reflects an estimate of the yearly change in temperature during the specified month and time period at that station.

In order to compute a simple estimate of the year-over-year average change in temperature in each month at each station, we'll first create a helper function. We are going to use linear regression. We'll use the statistical fact that, when regressing `Temp` against `Year`, the coefficient of `Year` will be an estimate of the yearly change in `Temp`.


```python
from sklearn.linear_model import LinearRegression

def coef(data_group):
    x = data_group[["Year"]] # 2 brackets because X should be a df
    y = data_group["Temp"]   # 1 bracket because y should be a series
    LR = LinearRegression()
    LR.fit(x, y)
    return round(LR.coef_[0], 4)
```

To get all month names, we will need another package called `calendar`.


```python
import calendar
```


```python
def temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):
    """
    purpose: Create visualizations to address the question:
             How does the average yearly change in temperature vary within a given country?
    input:country, a string giving the name of a country for which data should be returned.
           year_begin and year_end, two integers giving the earliest and latest years for which should be returned.
           month, an integer giving the month of the year for which should be returned.
           min_obs, the minimum required number of years of data for any given station. Only data for stations with at
                    least min_obs years worth of data in the specified month should be plotted; the others should be
                    filtered out. df.transform() plus filtering is a good way to achieve this task.
           **kwargs, additional keyword arguments passed to px.scatter_mapbox(). These can be used to control the
                     colormap used, the mapbox style, etc.
    output: An interactive geographic scatterplot, constructed using Plotly Express, with a point for each station,
            such that the color of the point reflects an estimate of the yearly change in temperature during the
            specified month and time period at that station.
    """
    
    df = query_climate_database(country, year_begin, year_end, month)
    df["ob"] = 1
    # calculate obs for each station
    df["ob"] = df.groupby(["NAME"])["ob"].transform(np.sum)
    # filtering out data for any given station that are less than the minimum required number of years
    df = df[df["ob"] >= min_obs]
    coefs = df.groupby(["NAME", "LATITUDE", "LONGITUDE", "ob"]).apply(coef)

    coefs = coefs.reset_index()

    
    fig = px.scatter_mapbox(coefs, 
                        lat = "LATITUDE", # latitude column
                        lon = "LONGITUDE", # longitude column
                        hover_name = "NAME", # Name of the hover label
                        color = 0, # colored by column "0"
                        color_continuous_midpoint = 0, # centered the color bar at 0
                        labels = {"0":"Estimated Yearly Increase (°C)"}, # add title to the colorbar
                        title = "Estimates of yearly increase in temperature in {month} for stations in {country}, years {year_begin} - {year_end}".format(
                        month = calendar.month_name[month], country = country, year_begin = year_begin, year_end = year_end), # add title to the plot
                        **kwargs)
    fig.update_layout(margin={"l": 0, "r": 0, "b": 0, "t": 80}) # set margins
    return fig
    
```

For example, we should be able to create a plot of estimated yearly increases in temperature during the month of January, in the interval 1980-2020, in India, as follows:


```python
# assumes you have imported necessary packages
color_map = px.colors.diverging.RdGy_r # choose a colormap

fig = temperature_coefficient_plot("India", 1980, 2020, 1, 
                                   min_obs = 10,
                                   zoom = 2,
                                   mapbox_style="carto-positron",
                                   color_continuous_scale=color_map)

fig.show()
```

To display the figure on the post, let’s first use write_html to save it and place it in the _include directory.


```python
from plotly.io import write_html
write_html(fig, "Blog-Post-1-Plot1.html")
```

{% include Blog-Post-1-Plot1.html %}

## 4.Create Two More Interesting Figures

### 1) How does the annual maximum and minimum temperature changes within a given station over the time?

This time we are going to do something different. We are going to make an animated line graph.

Before plotting, let's write a new query function to get all the information.


```python
def query_climate_database2(station):
    """
    purpose: Creat a pandas dataframe using SQL commands 
    input: station, a string giving the name of a station for which data should be returned.
    output: A Pandas dataframe of temperature readings for the specified station, with maximum reading of the year. 
    """
    # open the connection
    conn = sqlite3.connect("database.db")
    cmd = \
    """
    SELECT S.NAME, T.Year, MAX(T.Temp) AS MAX_T, MIN(T.Temp) AS MIN_T
    FROM stations S
    LEFT JOIN temperatures T ON S.ID = T.ID
    WHERE S.NAME = "{station}"
    GROUP BY T.Year
    """.format(station=station)
    
    df = pd.read_sql_query(cmd, conn)
    # close the connection
    conn.close()
    return df
```

Take the station "PBO_ANANTAPUR" as an example. If this code works, you should be able to get a dataframe looks like this:


```python
df = query_climate_database2("PBO_ANANTAPUR")
df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>Year</th>
      <th>MAX_T</th>
      <th>MIN_T</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>PBO_ANANTAPUR</td>
      <td>1973</td>
      <td>32.80</td>
      <td>23.12</td>
    </tr>
    <tr>
      <th>1</th>
      <td>PBO_ANANTAPUR</td>
      <td>1974</td>
      <td>32.73</td>
      <td>24.09</td>
    </tr>
    <tr>
      <th>2</th>
      <td>PBO_ANANTAPUR</td>
      <td>1975</td>
      <td>30.29</td>
      <td>23.22</td>
    </tr>
    <tr>
      <th>3</th>
      <td>PBO_ANANTAPUR</td>
      <td>1976</td>
      <td>29.73</td>
      <td>27.93</td>
    </tr>
    <tr>
      <th>4</th>
      <td>PBO_ANANTAPUR</td>
      <td>1977</td>
      <td>32.30</td>
      <td>23.30</td>
    </tr>
  </tbody>
</table>
</div>



Then, we are going to write a function called temperature_annimation_plot(). This function should accept one explicit argument.  
`Num_year`, an integer indicating which year this function is going to stop drawing.   
Notice that in order to decrease the time waiting for the program to run, this function is designed to work for a pre-defined dataframe obtained by running `query_climate_database2()` for a specific station. We will use df to indicate that dataframe inside this plotting function.  

The output of this function should be a line plot with a black background, containing two lines for max and min temperature from start to a given year.  
All the code and tutorial are modified from [here](https://towardsdatascience.com/how-to-visualise-sydneys-temperature-change-from-1859-to-2019-using-matplotlib-79b2dc7308c2).

Before we start, let's do some standard import.


```python
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()

from matplotlib import pyplot as plt
import matplotlib.ticker as ticker 
import matplotlib.animation as animation

# enable matplotlib display static plot within jupyter notebook
%matplotlib inline 
```

Then, let's so some setup work for formatting.


```python
# set up plot style as tron legancy
from matplotlib import cycler
colors = cycler('color',
                ['#fc280f', '#5fdcff', '#f4ba26', '#85c54c', '#c6d7e0']) # colors for artists will be cycled from this list by default
plt.rc('figure', facecolor='#222222') # facecolor is background colour
plt.rc('axes', facecolor='#222222', edgecolor='#222222',
       axisbelow=True, grid=True, prop_cycle=colors) # "axisbelow" set axis ticks and gridlines are below all artists
plt.rc('grid', color='#e3e3e3', linestyle='solid')
plt.rc('xtick', direction='in', color='#e3e3e3')
plt.rc('ytick', direction='in', color='#e3e3e3')
plt.rc('patch', edgecolor='#e3e3e3')
plt.rc('lines', linewidth=1.5)
```


```python
def draw_linechart(Num_Year):
    ''' 
    Purpose: Make a plot of a given data frame generated by query_climate_database2() for a specific year.
    Input: Num_year, an integer indicating which year this function is going to stop drawing.
    Output: a line plot with a black background, containing two lines for max and min temperature from start to a given year.
   '''
    
    # since many figures will be generated for animation, old axes need to be cleared before drawing new axes
    ax.clear() 
    ax2.clear()

    
    # select data till the indicated year
    df_tmp=df.loc[df['Year'] <= Num_Year] 
    
    # The frame of the whole figure, use the full data
    # excluding from the automatic legend element selection by 
    # defining a label starting with an underscore.
    ax.plot(df.Year, df.MAX_T*0, label='_1', color='#222222', zorder=1)
  
    # line plot
    ax.plot(df_tmp.Year, df_tmp.MAX_T, label='Yearly max. temp. ($^\circ$C)', 
            color='#fc280f', zorder=3)
    ax2.plot(df_tmp.Year, df_tmp.MIN_T, label='Yearly min. temp. ($^\circ$C)', 
            color='#0000FF', zorder=3)

    # dot at the end of the line
    ax.scatter(df_tmp.Year.values[-1], df_tmp.MAX_T.values[-1], color='#fc280f', s=60, edgecolor ='w', linewidth=1, zorder=4)
    ax2.scatter(df_tmp.Year.values[-1], df_tmp.MIN_T.values[-1], color='#0000FF', s=60, edgecolor ='w', linewidth=1, zorder=4)

    # text associated with the dot in the figure
    ax.text(df_tmp.Year.values[-1], df_tmp.MAX_T.values[-1]+5,
            s='MAX Temp. {}'.format(df_tmp.MAX_T.values[-1]), size=10, 
            color='#fc280f', ha='center', va='bottom', zorder=5)
    ax2.text(df_tmp.Year.values[-1], df_tmp.MIN_T.values[-1]+0.7, 
             s='MIN Temp. {}'.format(int(df_tmp.MIN_T.values[-1])), size=10, 
             color='#0000FF', ha='center', va='bottom', zorder=5)

    # display year in the background
    ax.text(0.5, 0.5, s=df_tmp.Year.values[-1], fontweight='bold', size=60, 
            color='#e3e3e3', ha='center', va="center", 
            alpha=0.5, transform=ax.transAxes, zorder=2)

    # legend for red line
    l1 = ax.legend(loc='upper left')
    
    for text in l1.get_texts():
        text.set_color('#e3e3e3')
    
    # legend for blue line
    l2 = ax2.legend(loc='upper right')
    
    for text in l2.get_texts():
        text.set_color('#e3e3e3')
    
    # set the y-axis to have enough space for other elements, such as legends
    ax.set_ylim(0, df.MAX_T.max()*1.68)
    # do not show the grid in the background
    ax.grid(visible=None)
    ax.set_ylabel('Temperatur ($^\circ$C)', color='#FFFFFF')
    
    ax2.grid(visible=None) # Don't show grid of ax2
    ax2.set_ylim(0, df.MAX_T.max()*1.68)
    ax2.set_ylabel('Temperature ($^\circ$C)', color='#FFFFFF')
    
    # set color for axes frame
    ax2.spines['bottom'].set_color('#FFFFFF')  
    ax2.spines['right'].set_color('#FFFFFF')  
    ax2.spines['left'].set_color('#FFFFFF')  
    ax2.spines['top'].set_color('#FFFFFF') 

    # Retrieve an element of a plot and set properties
    for tick in ax.xaxis.get_ticklabels():
        tick.set_fontsize('x-small')

    ax.margins(x=0.05)
    ax.text(0.00, 1.05, 'Annual Maximum Temperature From {year_b} to {year_e}'.format(year_b = df.Year.min(),
                                                                               year_e = df.Year.max()), color='#e3e3e3', 
             transform=ax.transAxes, size=15, weight='light', ha='left')
```

The principle of this function is to draw elements layer by layer. Let me explain the above function section by section.  
-  `ax.clear()` and `ax2.clear()`, the previous axes should be erased before plotting a new one, otherwise, old content in axes will be still left on the fig and recorded in the animation. This is also why I did not include `fig, ax = plt.subplots(figsize=(12,4), dpi=300)` and ax2 = `ax.twinx()` in the function body, but called them separately before `animation.FuncAnimation()`. The plotting space (i.e. `fig`, `ax`, and `ax2`) only need to be set once, just like a reusable whiteboard.
-  `df_tmp=df.loc[df[‘Year’] <= Num_Year]`, the input for plotting should be data. The new axes should contain data of current year and all its previous year (i.e. <=). Therefore, when animation.FuncAnimation call the draw_linechart using `Num_Year` in any given year, the lines in the static figure should span from the beginning (i.e. year 1973) to the called year.

-  `ax.plot(df.Year, df.MAX_T*0, label=’_1', color=’#222222', zorder=1)`, this is the first line plot. Notice that the data used here is not `df_tmp` but full dataframe df. This section is to create a frame spanned from the beginning year (1973) to the end year (2021) for each axes of `df_tmp`. This ensures the x-axis of each axes has the same year range (i.e. 1973–2021) instead of changing along with the year range of `df_tmp` (i.e. 1973-Num_Year). In addition, I only need the frame and the line should be hid for this layer so that I timed 0 for each value (df.MAX_T) in y-axis. You may notice that the value assigned to label contains an underscore, this is to exclude this layer from being displayed by the automatic legend element selection later (`ax.legend()`). Another argument used here is `zorder`, which can be considered as the layer sequence along z-axis and 1 means the bottom layer.
-  From `ax.plot()` to `ax2.plot()`, these add two horizontal lines to make it easy for audience to estimate the value of maximum temperature and minimum temperature each year.
-  From `ax.plot()` to `ax.text()` this is the part for drawing most elements (lines, head dot, text running with head dot) in the fig. It is very straightforward to understand. The only thing I want to highlight again here is the power of `ax.xxx()`, which made the manipulations of each axes easy enough.

After setting up the draw_linechart function, let’s draw a static graph by input a specific year. If everything goes right, you will see the plot below.


```python
fig, ax = plt.subplots(figsize=(12,4), dpi=300)
ax2 = ax.twinx()
draw_linechart(2014)
```

To create this example, I first ran the code in a Jupyter Notebook, and added the line `
plt.savefig("Blog-Post-1-Plot2.png")` to save the result. I then moved the file `Blog-Post-1-Plot2.png` to the `images/` directory of my blog. Finally, I added the line 
```
![image-Blog-Post-1-Plot2.png]({{ site.baseurl }}/images/image-Blog-Post-1-Plot2.png)
```
immediately beneath the code block. 

![image-Blog-Post-1-Plot2.png](https://raw.githubusercontent.com/JadenWSR/JadenWSR.github.io/master/images/image--Blog-Post-1-Plot2.png)

Running the following code will generate all frames and assign them to the object animator. Then this object can be saved as mp4. The last note is that fig background colour should be specified using `savefig_kwargs={‘facecolor’:’#222222'}`, otherwise it will be saved as white which is not consistent with the Tron legancy theme.


```python
animator = animation.FuncAnimation(fig, draw_linechart, 
                                   frames=np.arange(df.Year.values.min(),df.Year.values.max(),1), interval=300)
```


```python
# you need install ffmpeg before running this code
animator.save('./animation4.gif', savefig_kwargs={'facecolor':'#222222'}) # savefig_kwargs need to be specified to save figure background
# see https://github.com/matplotlib/matplotlib/issues/1008/
```

There might be missing data for a specific station. Thus the video might stop for a while and then continue drawing.


https://user-images.githubusercontent.com/97017736/150475347-5f2310bd-0c34-4275-8bf0-0f5f70509aaf.mp4


### 2）For each average yearly temperature reading, how does that reading compare to the average reading within a given range of latitude and longitude and a given year range?

To create this visualization, we will use the `plotly` package.


```python
from plotly import express as px
import plotly.io as pio
```

To make the question concrete, let's say that a annual average temperature in a given year at the given region is anomalous if it is more than two standard deviations away from the mean for that month. If you've taken a statistics class, this is the same as requiring that the z-score for that month is larger than 2 in absolute value. In other words, we need to look at the condition where |z| > 2.

Here's a simple function to compute the absolute z-scores of an array:


```python
def z_score(x):
    m = np.mean(x)
    s = np.std(x)
    return abs((x - m)/s)
```

Next, we will create a query function to create the dataframe we wanted. Similarly to previous steps, we can easily construct one and test it.


```python
def query_climate_database3(year_begin, year_end , lat_b, lat_e, long_b, long_e):
    """
    purpose: Creat a pandas dataframe using SQL commands containing the z-score of annual yearly readings
    input: year_begin and year_end, two integers giving the earliest and latest years for which should be returned.
           lat_b and lat_e, two integers giving the range of latitude for which should be returned.
           long_b and long_e, two integers giving the range of longitude for which should be returned.
    output: A Pandas dataframe of temperature readings for the specified country, in the specified date range, in the specified month of the year. 
    """
    # open the connection
    conn = sqlite3.connect("database.db")
    
    cmd = \
    """
    SELECT S.NAME, S.LATITUDE, S.LONGITUDE, C.Country, T.Year, AVG(T.Temp) AS AVG_T
    FROM stations S
    LEFT JOIN temperatures T ON S.ID = T.ID
    LEFT JOIN countries C ON SUBSTRING (T.ID, 1, 2) = C.`FIPS_10-4`
    WHERE T.Year >= {year_begin} AND T.Year <= {year_end} AND S.LATITUDE <= {lat_e} AND S.LATITUDE >= {lat_b} AND S.LONGITUDE <= {long_e} AND S.LONGITUDE >= {long_b}
    GROUP BY S.NAME, T.Year
    """.format(year_begin=year_begin, year_end = year_end, lat_e=lat_e, lat_b=lat_b, long_e=long_e, long_b = long_b)
    
    df = pd.read_sql_query(cmd, conn)
    df["ABS_Z"] = df.groupby(["Year"])["AVG_T"].transform(z_score)
    
    # close the connection
    conn.close()
    return df
```

We can simpily testing this code by running:


```python
df = query_climate_database3(2004, 2006, 15, 60, 55, 70)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>Year</th>
      <th>AVG_T</th>
      <th>ABS_Z</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACHISAJ</td>
      <td>43.550</td>
      <td>68.900</td>
      <td>Kazakhstan</td>
      <td>2004</td>
      <td>11.875833</td>
      <td>0.157579</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ACHISAJ</td>
      <td>43.550</td>
      <td>68.900</td>
      <td>Kazakhstan</td>
      <td>2005</td>
      <td>12.050000</td>
      <td>0.172269</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ACHISAJ</td>
      <td>43.550</td>
      <td>68.900</td>
      <td>Kazakhstan</td>
      <td>2006</td>
      <td>11.465000</td>
      <td>0.233012</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ADAM_AIRPORT</td>
      <td>22.500</td>
      <td>57.367</td>
      <td>Oman</td>
      <td>2004</td>
      <td>29.150000</td>
      <td>1.742622</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ADAM_AIRPORT</td>
      <td>22.500</td>
      <td>57.367</td>
      <td>Oman</td>
      <td>2005</td>
      <td>29.195833</td>
      <td>1.761449</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>543</th>
      <td>ZLATOUST</td>
      <td>55.170</td>
      <td>59.670</td>
      <td>Russia</td>
      <td>2006</td>
      <td>1.905000</td>
      <td>1.260670</td>
    </tr>
    <tr>
      <th>544</th>
      <td>ZLIKHA</td>
      <td>45.250</td>
      <td>67.067</td>
      <td>Kazakhstan</td>
      <td>2004</td>
      <td>10.744167</td>
      <td>0.282065</td>
    </tr>
    <tr>
      <th>545</th>
      <td>ZLIKHA</td>
      <td>45.250</td>
      <td>67.067</td>
      <td>Kazakhstan</td>
      <td>2005</td>
      <td>10.463333</td>
      <td>0.351214</td>
    </tr>
    <tr>
      <th>546</th>
      <td>ZLIKHA</td>
      <td>45.250</td>
      <td>67.067</td>
      <td>Kazakhstan</td>
      <td>2006</td>
      <td>9.853333</td>
      <td>0.406259</td>
    </tr>
    <tr>
      <th>547</th>
      <td>ZVERINOGOLOVSKAJA</td>
      <td>54.467</td>
      <td>64.867</td>
      <td>Russia</td>
      <td>2004</td>
      <td>1.153333</td>
      <td>1.337081</td>
    </tr>
  </tbody>
</table>
<p>548 rows × 7 columns</p>
</div>



Then, let's write a function to make a bar plot. The color of the plot indicates the value of absolute z score. We should be able to get all information of a single station from hover labels. The resulting plot is separated to severval subplots by countries.


```python
def bar_z_plot(year_begin, year_end, lat_b, lat_e, long_b, long_e, **kwargs):
    """
    purpose: Create visualizations to address the question:
             For each average yearly temperature reading, how does that reading compare to the average
             reading within a given range of latitude and longitude and a given year range?
    input:year_begin and year_end, two integers giving the earliest and latest years for which should be returned.
          lat_b and lat_e, two integers giving the range of latitude for which should be returned.
          long_b and long_e, two integers giving the range of longitude for which should be returned.
          **kwargs, additional keyword arguments passed to px.scatter_mapbox(). These can be used to control the
                     colormap used, the mapbox style, etc.
    output: An interactive bar chart, constructed using Plotly Express, with a point for each station,
            such that the color of the point reflects the absolute z score of annual average temperature during the
            specified year period and within a specific location.
    """
    df = query_climate_database3(year_begin, year_end, lat_b, lat_e, long_b, long_e)
    pio.templates.default = "plotly_white"


    fig = px.bar(data_frame = df, # data set
                     x = "Year",  # column for x axis
                     y = "AVG_T", # column for y axis
                     color = "ABS_Z", # column for dot color
                     hover_name = "NAME", # Name of the hover label
                     hover_data = ["Year", "Country", "AVG_T", "ABS_Z"],  # extra columns contained in hover label
                     facet_col = "Country", # column for column facets
                     labels = {"ABS_Z":"Absolute Z Score"}, # add title to the colorbar
                     title = "Average Annual Temperature and Z-Score from {y_b} to {y_e} <br> for stations between latitude {lab}-{lae} and longtitude {long_b}-{long_e}".format(
                         y_b=year_begin, y_e = year_end, lab=lat_b, lae=lat_e, long_b=long_b, long_e=long_e), 
                    **kwargs) # column for column facets
    fig.update_layout(yaxis_title="Average Annual Temperature(°C)")
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1]))

    return fig

```

We will test this function using `year_begin` = 2004, `year_end` = 2006, `lat_b` = 15, `lat_e` = 35, `long_b` = 55, and `long_e` = 70.


```python
fig = bar_z_plot(2004, 2006, 15, 35, 55, 70, 
                   width = 600, # width of figure
                   height = 400, # height of figure
                   opacity = 0.5, # adjust opacity
                   color_continuous_scale='Bluered_r') # set color scale
fig.show()
```

From the plot we could answer the question easily. The red bars looks normal with a low absolute z score. The more blue the bar is, the more unusual it would be.

To display the figure on the post, let’s first use write_html to save it and place it in the _include directory.


```python
from plotly.io import write_html
write_html(fig, "Blog-Post-1-Plot3.html")
```

{% include Blog-Post-1-Plot3.html %}

### 3）Within a specific country, does the temperature of a randomly chosen station have any seasonalities?

To answer this question, we will randomly choose a station from a given country and make a seasonal boxplot.

First, let's write a query function. The percedure is very similar to the previous notes.


```python
def query_climate_database4(country):
    """
    purpose: Creat a pandas dataframe using SQL commands 
    input: country, a string giving the name of a country for which data should be returned.
    output: A Pandas dataframe of temperature readings for the specified country, randomly chosen station. 
    """
    # open the connection
    conn = sqlite3.connect("database.db")
    
    
    S_Name = pd.read_sql_query("""
    SELECT S.NAME
    FROM stations S
    LEFT JOIN temperatures T ON S.ID = T.ID
    LEFT JOIN countries C ON SUBSTRING (T.ID, 1, 2) = C.`FIPS_10-4`
    WHERE C.Country = '{country}'
    ORDER BY RANDOM() LIMIT 1
    """.format(country=country), conn)
    S_Name = S_Name["NAME"].values[0]
    
    
    cmd = \
    """
    SELECT S.NAME, C.Country, T.Year, T.Month, T.Temp
    FROM stations S
    LEFT JOIN temperatures T ON S.ID = T.ID
    LEFT JOIN countries C ON SUBSTRING (T.ID, 1, 2) = C.`FIPS_10-4`
    WHERE C.Country = '{country}' AND S.NAME = '{S_Name}'
    """.format(country=country, S_Name = S_Name)
    
    df = pd.read_sql_query(cmd, conn)
    # Transfer month number to month names
    df['Month'] = df['Month'].apply(lambda x: calendar.month_abbr[x])
    # close the connection
    conn.close()
    return df
```

If our function is correct, the output should look exactly like this one:


```python
df = query_climate_database4("China")
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>Country</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>LISHI</td>
      <td>China</td>
      <td>1957</td>
      <td>Jan</td>
      <td>-6.98</td>
    </tr>
    <tr>
      <th>1</th>
      <td>LISHI</td>
      <td>China</td>
      <td>1957</td>
      <td>Feb</td>
      <td>-6.73</td>
    </tr>
    <tr>
      <th>2</th>
      <td>LISHI</td>
      <td>China</td>
      <td>1957</td>
      <td>Mar</td>
      <td>4.62</td>
    </tr>
    <tr>
      <th>3</th>
      <td>LISHI</td>
      <td>China</td>
      <td>1957</td>
      <td>Apr</td>
      <td>10.76</td>
    </tr>
    <tr>
      <th>4</th>
      <td>LISHI</td>
      <td>China</td>
      <td>1957</td>
      <td>May</td>
      <td>15.22</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>661</th>
      <td>LISHI</td>
      <td>China</td>
      <td>2013</td>
      <td>Aug</td>
      <td>23.62</td>
    </tr>
    <tr>
      <th>662</th>
      <td>LISHI</td>
      <td>China</td>
      <td>2013</td>
      <td>Sep</td>
      <td>17.90</td>
    </tr>
    <tr>
      <th>663</th>
      <td>LISHI</td>
      <td>China</td>
      <td>2013</td>
      <td>Oct</td>
      <td>11.99</td>
    </tr>
    <tr>
      <th>664</th>
      <td>LISHI</td>
      <td>China</td>
      <td>2013</td>
      <td>Nov</td>
      <td>3.04</td>
    </tr>
    <tr>
      <th>665</th>
      <td>LISHI</td>
      <td>China</td>
      <td>2013</td>
      <td>Dec</td>
      <td>-3.78</td>
    </tr>
  </tbody>
</table>
<p>666 rows × 5 columns</p>
</div>



Then, let's draw a interactive seasonal boxplot. This is a relatively simple plot compared to previous plots.


```python
def seasonal_box_plot(country, **kwargs):
    """
    purpose: Create visualizations to address the question:
             Within a specific country, does the temperature of a randomly chosen station have any seasonalities?
    input:country, a string giving the name of a country for which data should be returned.
          **kwargs, additional keyword arguments passed to px.scatter_mapbox(). These can be used to control the
                     colormap used, the mapbox style, etc.
    output: An interactive seaasonal boxplot, constructed using Plotly Express.
    """
    # Construct the dataframe
    df = query_climate_database4(country)
    station = df["NAME"][0]
    
    # Create Seasonal Boxplot
    
    pio.templates.default = "plotly_white"


    fig = px.box(data_frame = df, # data set
                 x = "Month",  # column for x axis
                 y = "Temp", # column for y axis
                 color = "Month", # column for box color
                 hover_name = "NAME", # Name of the hover label
                 hover_data = ["Year", "Country", "Month", "Temp"],  # extra columns contained in hover label
                 title = "Seasonal Boxplot for {station} <br>a randomly chosen station in {country}".format(
                 station = station, country = country), 
                **kwargs) # column for column facets
    fig.update_layout(yaxis_title="Temperature(°C)")


    # reduce whitespace
  #  fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
    return fig
    
```

We will test this function using `country` = 'China'.


```python
fig = seasonal_box_plot("China", width = 800, height = 600)
fig.show()
```

To display the figure on the post, let’s first use write_html to save it and place it in the _include directory.


```python
from plotly.io import write_html
write_html(fig, "Blog-Post-1-Plot4.html")
```

{% include Blog-Post-1-Plot4.html %}
